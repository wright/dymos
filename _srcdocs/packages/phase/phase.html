

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>phase.py &#8212; dymos 0.14.2 documentation</title>
    <link rel="stylesheet" href="../../../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="dymos.transcriptions" href="../dymos.transcriptions.html" />
    <link rel="prev" title="options.py" href="options.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../dymos.transcriptions.html" title="dymos.transcriptions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="options.html" title="options.py"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">dymos 0.14.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Source Docs</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../dymos.phase.html" accesskey="U">dymos.phase</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="options.html"
                        title="previous chapter">options.py</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../dymos.transcriptions.html"
                        title="next chapter">dymos.transcriptions</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/_srcdocs/packages/phase/phase.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-dymos.phase.phase">
<span id="phase-py"></span><span id="dymos-phase-phase-py"></span><span id="index-0"></span><h1>phase.py<a class="headerlink" href="#module-dymos.phase.phase" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="dymos.phase.phase.Phase">
<em class="property">class </em><code class="sig-prename descclassname">dymos.phase.phase.</code><code class="sig-name descname">Phase</code><span class="sig-paren">(</span><em class="sig-param">from_phase=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">openmdao.core.group.Group</span></code></p>
<p>The Phase object in Dymos.</p>
<p>The Phase object is an OpenMDAO Group which contains the options for the variables in the
optimal control problem (states, times, controls, parameters), the transcription, and
the ODE class.</p>
<p>The role of the Phase is to unite the problem formulation with the transcription and the ODE
in order to transcribe a single portion of a trajectory into a nonlinear programming problem
to be solved by the optimizer.</p>
<p>On setup, the Phase runs through its setup stack which will add the appropriate OpenMDAO
systems as prescribed by its associated Transcription.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>from_phase: Phase or None</strong></dt><dd><p>A phase instance from which the initialized phase should copy its data.</p>
</dd>
<dt><strong>transcription: TranscriptionBase</strong></dt><dd><p>The transcription to be utilized within the Phase.</p>
</dd>
<dt><strong>ode_class</strong></dt><dd><p>An OpenMDAO system class serving as the ODE for the phase.</p>
</dd>
<dt><strong>ode_init_kwargs: dict</strong></dt><dd><p>Keyword arguments used to initialize ode_class.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="dymos.phase.phase.Phase.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">from_phase=None</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the solvers to nonlinear and linear block Gauss–Seidel by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>**kwargs</strong><span class="classifier">dict</span></dt><dd><p>dict of arguments available here and in all descendants of this
Group.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">subsys</em>, <em class="sig-param">promotes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a subsystem (deprecated version of &lt;Group.add_subsystem&gt;).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of the subsystem being added</p>
</dd>
<dt><strong>subsys</strong><span class="classifier">System</span></dt><dd><p>An instantiated, but not-yet-set up system object.</p>
</dd>
<dt><strong>promotes</strong><span class="classifier">iter of str, optional</span></dt><dd><p>A list of variable names specifying which subsystem variables
to ‘promote’ up to this group. This is for backwards compatibility
with older versions of OpenMDAO.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>System</strong><span class="classifier"></span></dt><dd><p>The System that was passed in.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_boundary_constraint">
<code class="sig-name descname">add_boundary_constraint</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">loc</em>, <em class="sig-param">constraint_name=None</em>, <em class="sig-param">units=None</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">equals=None</em>, <em class="sig-param">scaler=None</em>, <em class="sig-param">adder=None</em>, <em class="sig-param">ref=None</em>, <em class="sig-param">ref0=None</em>, <em class="sig-param">linear=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_boundary_constraint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_boundary_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a boundary constraint to a variable in the phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Name of the variable to constrain.  If name is not a state, control, or ‘time’,
then this is assumed to be the path of the variable to be constrained in the ODE.</p>
</dd>
<dt><strong>loc</strong><span class="classifier">string</span></dt><dd><p>The location of the boundary constraint (‘initial’ or ‘final’)</p>
</dd>
<dt><strong>constraint_name</strong><span class="classifier">string or None</span></dt><dd><p>The name of the variable as provided to the boundary constraint comp.  By
default this is the last element in <cite>name</cite> when split by dots.  The user may
override the constraint name if splitting the path causes name collisions.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str or None</span></dt><dd><p>The units in which the boundary constraint is to be applied.  If None, use the
units associated with the constrained output.  If provided, must be compatible with
the variables units.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple, list, ndarray, or None</span></dt><dd><p>The shape of the variable being boundary-constrained.  This can be inferred
automatically for time, states, controls, and input/design parameters, but is required
if the constrained variable is an output of the ODE system.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">tuple, list, ndarray, or None</span></dt><dd><p>The indices of the output variable to be boundary constrained.  Indices assumes C-order
flattening.  For instance, when constraining element [0, 1] of a variable of shape
[2, 2], indices would be [3].</p>
</dd>
<dt><strong>lower</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Lower boundary for the variable</p>
</dd>
<dt><strong>upper</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Upper boundary for the variable</p>
</dd>
<dt><strong>equals</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Equality constraint value for the variable</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 1.0 in the driver.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 0.0 in the driver.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value to add to the model value to get the scaled value. Adder
is first in precedence.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>value to multiply the model value to get the scaled value. Scaler
is second in precedence.</p>
</dd>
<dt><strong>linear</strong><span class="classifier">bool</span></dt><dd><p>Set to True if constraint is linear. Default is False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_constraint">
<code class="sig-name descname">add_constraint</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">equals=None</em>, <em class="sig-param">ref=None</em>, <em class="sig-param">ref0=None</em>, <em class="sig-param">adder=None</em>, <em class="sig-param">scaler=None</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">linear=False</em>, <em class="sig-param">parallel_deriv_color=None</em>, <em class="sig-param">vectorize_derivs=False</em>, <em class="sig-param">cache_linear_solution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.add_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a constraint variable to this system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Name of the response variable in the system.</p>
</dd>
<dt><strong>lower</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Lower boundary for the variable</p>
</dd>
<dt><strong>upper</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Upper boundary for the variable</p>
</dd>
<dt><strong>equals</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Equality constraint value for the variable</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 1.0 in the driver.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 0.0 in the driver.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value to add to the model value to get the scaled value for the driver. adder
is first in precedence.  adder and scaler are an alterantive to using ref
and ref0.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>value to multiply the model value to get the scaled value for the driver. scaler
is second in precedence. adder and scaler are an alterantive to using ref
and ref0.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">sequence of int, optional</span></dt><dd><p>If variable is an array, these indicate which entries are of
interest for this particular response.  These may be positive or
negative integers.</p>
</dd>
<dt><strong>linear</strong><span class="classifier">bool</span></dt><dd><p>Set to True if constraint is linear. Default is False.</p>
</dd>
<dt><strong>parallel_deriv_color</strong><span class="classifier">string</span></dt><dd><p>If specified, this design var will be grouped for parallel derivative
calculations with other variables sharing the same parallel_deriv_color.</p>
</dd>
<dt><strong>vectorize_derivs</strong><span class="classifier">bool</span></dt><dd><p>If True, vectorize derivative calculations.</p>
</dd>
<dt><strong>cache_linear_solution</strong><span class="classifier">bool</span></dt><dd><p>If True, store the linear solution vectors for this variable so they can
be used to start the next linear solution with an initial guess equal to the
solution from the previous linear solve.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The response can be scaled using ref and ref0.
The argument <code class="code docutils literal notranslate"><span class="pre">ref0</span></code> represents the physical value when the scaled value is 0.
The argument <code class="code docutils literal notranslate"><span class="pre">ref</span></code> represents the physical value when the scaled value is 1.
The arguments (<code class="code docutils literal notranslate"><span class="pre">lower</span></code>, <code class="code docutils literal notranslate"><span class="pre">upper</span></code>, <code class="code docutils literal notranslate"><span class="pre">equals</span></code>) can not be strings or variable
names.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_control">
<code class="sig-name descname">add_control</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">units=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">desc=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">opt=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_initial=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_final=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate_targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate2_targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">val=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">shape=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">lower=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">upper=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">adder=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref0=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">continuity=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">continuity_scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate_continuity=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate_continuity_scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate2_continuity=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate2_continuity_scaler=&lt;object object at 0x7f47d33f6670&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_control"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a dynamic control variable to be tied to a parameter in the ODE.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name assigned to the control variable.  If the ODE has been decorated with
parameters, this should be the name of a control in the system.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str or None</span></dt><dd><p>The units with which the control parameter in this phase will be defined.  It must be
compatible with the units of the targets to which the control is connected.</p>
</dd>
<dt><strong>desc</strong><span class="classifier">str</span></dt><dd><p>A description of the control variable.</p>
</dd>
<dt><strong>opt</strong><span class="classifier">bool</span></dt><dd><p>If True, the control value will be a design variable for the optimization problem.
If False, allow the control to be connected externally.</p>
</dd>
<dt><strong>fix_initial</strong><span class="classifier">bool</span></dt><dd><p>If True, the initial value of this control is fixed and not a design variable.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>fix_final</strong><span class="classifier">bool</span></dt><dd><p>If True, the final value of this control is fixed and not a design variable.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">Sequence of str or None</span></dt><dd><p>Targets in the ODE to which this control is connected.</p>
</dd>
<dt><strong>rate_targets</strong><span class="classifier">Sequence of str or None</span></dt><dd><p>The targets in the ODE to which the control rate is connected.</p>
</dd>
<dt><strong>rate2_targets</strong><span class="classifier">Sequence of str or None</span></dt><dd><p>The parameter in the ODE to which the control 2nd derivative is connected.</p>
</dd>
<dt><strong>val</strong><span class="classifier">float</span></dt><dd><p>The default value of the control variable at the control input nodes.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">Sequence of int</span></dt><dd><p>The shape of the control variable at each point in time.</p>
</dd>
<dt><strong>lower</strong><span class="classifier">Sequence of Number or None</span></dt><dd><p>The lower bound of the control variable at the nodes.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>upper</strong><span class="classifier">Sequence or Number or None</span></dt><dd><p>The upper bound of the control variable at the nodes.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or None</span></dt><dd><p>The scaler of the control variable at the nodes.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or None</span></dt><dd><p>The adder of the control variable at the nodes.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or None</span></dt><dd><p>The zero-reference value of the control variable at the nodes.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or None</span></dt><dd><p>The unit-reference value of the control variable at the nodes.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>continuity</strong><span class="classifier">bool</span></dt><dd><p>Enforce continuity of control values at segment boundaries.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>continuity_scaler</strong><span class="classifier">bool</span></dt><dd><p>Scaler of the continuity constraint. This option is invalid if opt=False.  This
option is only relevant in the Radau pseudospectral transcription where the continuity
constraint is nonlinear.  For Gauss-Lobatto the continuity constraint is linear.</p>
</dd>
<dt><strong>rate_continuity</strong><span class="classifier">bool</span></dt><dd><p>Enforce continuity of control first derivatives  (in dimensionless time) at
segment boundaries.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>rate_continuity_scaler</strong><span class="classifier">float</span></dt><dd><p>Scaler of the rate continuity constraint at segment boundaries.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>rate2_continuity</strong><span class="classifier">bool</span></dt><dd><p>Enforce continuity of control second derivatives at segment boundaries.
This option is invalid if opt=False.</p>
</dd>
<dt><strong>rate2_continuity_scaler</strong><span class="classifier">float</span></dt><dd><p>Scaler of the dimensionless rate continuity constraint at segment boundaries.
This option is invalid if opt=False.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>rate and rate2 continuity are not enforced for input controls.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_design_parameter">
<code class="sig-name descname">add_design_parameter</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">val=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">units=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">opt=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">desc=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">lower=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">upper=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">adder=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref0=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">shape=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">dynamic=&lt;object object at 0x7f47d33f6670&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_design_parameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_design_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a design parameter (static control variable) to the phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of the design parameter.</p>
</dd>
<dt><strong>val</strong><span class="classifier">float or ndarray</span></dt><dd><p>Default value of the design parameter at all nodes.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str or None or 0</span></dt><dd><p>Units in which the design parameter is defined.  If 0, use the units declared
for the parameter in the ODE.</p>
</dd>
<dt><strong>opt</strong><span class="classifier">bool</span></dt><dd><p>If True (default) the value(s) of this design parameter will be design variables in
the optimization problem, in the path ‘phase_name.indep_controls.controls:control_name’.
If False, the this design parameter will still be owned by an IndepVarComp in the phase,
but it will not be a design variable in the optimization.</p>
</dd>
<dt><strong>desc</strong><span class="classifier">str</span></dt><dd><p>A description of the design parameter.</p>
</dd>
<dt><strong>lower</strong><span class="classifier">float or ndarray</span></dt><dd><p>The lower bound of the design parameter value.</p>
</dd>
<dt><strong>upper</strong><span class="classifier">float or ndarray</span></dt><dd><p>The upper bound of the design parameter value.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray</span></dt><dd><p>The scaler of the design parameter value for the optimizer.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray</span></dt><dd><p>The adder of the design parameter value for the optimizer.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or ndarray</span></dt><dd><p>The zero-reference value of the design parameter for the optimizer.</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray</span></dt><dd><p>The unit-reference value of the design parameter for the optimizer.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">Sequence of str or None</span></dt><dd><p>Targets in the ODE to which this parameter is connected.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">Sequence of int</span></dt><dd><p>The shape of the design parameter.</p>
</dd>
<dt><strong>dynamic</strong><span class="classifier">bool</span></dt><dd><p>True if the targets in the ODE may be dynamic (if the inputs are sized to the number
of nodes) else False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_design_var">
<code class="sig-name descname">add_design_var</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">ref=None</em>, <em class="sig-param">ref0=None</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">adder=None</em>, <em class="sig-param">scaler=None</em>, <em class="sig-param">parallel_deriv_color=None</em>, <em class="sig-param">vectorize_derivs=False</em>, <em class="sig-param">cache_linear_solution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.add_design_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a design variable to this system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Name of the design variable in the system.</p>
</dd>
<dt><strong>lower</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Lower boundary for the param</p>
</dd>
<dt><strong>upper</strong><span class="classifier">upper or ndarray, optional</span></dt><dd><p>Upper boundary for the param</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of design var that scales to 1.0 in the driver.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of design var that scales to 0.0 in the driver.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">iter of int, optional</span></dt><dd><p>If a param is an array, these indicate which entries are of
interest for this particular design variable.  These may be
positive or negative integers.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value to add to the model value to get the scaled value for the driver. adder
is first in precedence.  adder and scaler are an alterantive to using ref
and ref0.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>value to multiply the model value to get the scaled value for the driver. scaler
is second in precedence. adder and scaler are an alterantive to using ref
and ref0.</p>
</dd>
<dt><strong>parallel_deriv_color</strong><span class="classifier">string</span></dt><dd><p>If specified, this design var will be grouped for parallel derivative
calculations with other variables sharing the same parallel_deriv_color.</p>
</dd>
<dt><strong>vectorize_derivs</strong><span class="classifier">bool</span></dt><dd><p>If True, vectorize derivative calculations.</p>
</dd>
<dt><strong>cache_linear_solution</strong><span class="classifier">bool</span></dt><dd><p>If True, store the linear solution vectors for this variable so they can
be used to start the next linear solution with an initial guess equal to the
solution from the previous linear solve.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The response can be scaled using ref and ref0.
The argument <code class="code docutils literal notranslate"><span class="pre">ref0</span></code> represents the physical value when the scaled value is 0.
The argument <code class="code docutils literal notranslate"><span class="pre">ref</span></code> represents the physical value when the scaled value is 1.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_input_parameter">
<code class="sig-name descname">add_input_parameter</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">val=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">units=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">desc=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">shape=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">dynamic=&lt;object object at 0x7f47d33f6670&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_input_parameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_input_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an input parameter (static control variable) to the phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of the ODE parameter to be controlled via this input parameter.</p>
</dd>
<dt><strong>val</strong><span class="classifier">float or ndarray</span></dt><dd><p>Default value of the design parameter at all nodes.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str or None or 0</span></dt><dd><p>Units in which the design parameter is defined.  If 0, use the units declared
for the parameter in the ODE.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">Sequence of str or None</span></dt><dd><p>Targets in the ODE to which this parameter is connected.</p>
</dd>
<dt><strong>desc</strong><span class="classifier">str</span></dt><dd><p>A description of the input parameter</p>
</dd>
<dt><strong>shape</strong><span class="classifier">Sequence of str or None</span></dt><dd><p>The shape of the input parameter.</p>
</dd>
<dt><strong>dynamic</strong><span class="classifier">bool</span></dt><dd><p>True if the targets in the ODE may be dynamic (if the inputs are sized to the number
of nodes) else False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_objective">
<code class="sig-name descname">add_objective</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">loc='final'</em>, <em class="sig-param">index=None</em>, <em class="sig-param">shape=(1</em>, <em class="sig-param">)</em>, <em class="sig-param">ref=None</em>, <em class="sig-param">ref0=None</em>, <em class="sig-param">adder=None</em>, <em class="sig-param">scaler=None</em>, <em class="sig-param">parallel_deriv_color=None</em>, <em class="sig-param">vectorize_derivs=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_objective"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Allows the user to add an objective in the phase.  If name is not a state,
control, control rate, or ‘time’, then this is assumed to be the path of the variable
to be constrained in the RHS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of the objective variable.  This should be one of ‘time’, a state or control
variable, or the path to an output from the top level of the RHS.</p>
</dd>
<dt><strong>loc</strong><span class="classifier">str</span></dt><dd><p>Where in the phase the objective is to be evaluated.  Valid
options are ‘initial’ and ‘final’.  The default is ‘final’.</p>
</dd>
<dt><strong>index</strong><span class="classifier">int, optional</span></dt><dd><p>If variable is an array at each point in time, this indicates which index is to be
used as the objective, assuming C-ordered flattening.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">int, optional</span></dt><dd><p>The shape of the objective variable, at a point in time</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 1.0 in the driver.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 0.0 in the driver.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value to add to the model value to get the scaled value. Adder
is first in precedence.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>value to multiply the model value to get the scaled value. Scaler
is second in precedence.</p>
</dd>
<dt><strong>parallel_deriv_color</strong><span class="classifier">string</span></dt><dd><p>If specified, this design var will be grouped for parallel derivative
calculations with other variables sharing the same parallel_deriv_color.</p>
</dd>
<dt><strong>vectorize_derivs</strong><span class="classifier">bool</span></dt><dd><p>If True, vectorize derivative calculations.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_path_constraint">
<code class="sig-name descname">add_path_constraint</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">constraint_name=None</em>, <em class="sig-param">units=None</em>, <em class="sig-param">shape=None</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">equals=None</em>, <em class="sig-param">scaler=None</em>, <em class="sig-param">adder=None</em>, <em class="sig-param">ref=None</em>, <em class="sig-param">ref0=None</em>, <em class="sig-param">linear=False</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_path_constraint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_path_constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a path constraint to a variable in the phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Name of the response variable in the system.</p>
</dd>
<dt><strong>constraint_name</strong><span class="classifier">string or None</span></dt><dd><p>The name of the variable as provided to the boundary constraint comp.  By
default this is the last element in <cite>name</cite> when split by dots.  The user may
override the constraint name if splitting the path causes name collisions.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str or None</span></dt><dd><p>The units in which the boundary constraint is to be applied.  If None, use the
units associated with the constrained output.  If provided, must be compatible with
the variables units.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple, list, ndarray, or None</span></dt><dd><p>The shape of the variable being boundary-constrained.  This can be inferred
automatically for time, states, controls, and input/design parameters, but is required
if the constrained variable is an output of the ODE system.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">tuple, list, ndarray, or None</span></dt><dd><p>The indices of the output variable to be path constrained.  Indices assumes C-order
flattening.  For instance, when constraining element [0, 1] of a variable of shape
[2, 2], indices would be [3].</p>
</dd>
<dt><strong>lower</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Lower boundary for the variable</p>
</dd>
<dt><strong>upper</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Upper boundary for the variable</p>
</dd>
<dt><strong>equals</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Equality constraint value for the variable</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 1.0 in the driver.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 0.0 in the driver.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value to add to the model value to get the scaled value. Adder
is first in precedence.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>value to multiply the model value to get the scaled value. Scaler
is second in precedence.</p>
</dd>
<dt><strong>linear</strong><span class="classifier">bool</span></dt><dd><p>Set to True if constraint is linear. Default is False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_polynomial_control">
<code class="sig-name descname">add_polynomial_control</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">order</em>, <em class="sig-param">desc=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">val=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">units=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">opt=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_initial=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_final=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">lower=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">upper=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">adder=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref0=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate_targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate2_targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">shape=&lt;object object at 0x7f47d33f6670&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_polynomial_control"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_polynomial_control" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an polynomial control variable to be tied to a parameter in the ODE.</p>
<p>Polynomial controls are defined by values at the Legendre-Gauss-Lobatto nodes of a
single polynomial, defined on [-1, 1] in phase tau space.</p>
<p>For a polynomial control of a given order, the number of nodes used to define the
polynomial is (order + 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of the controllable parameter in the ODE.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int</span></dt><dd><p>The order of the interpolating polynomial used to represent the control valeu in
phase tau space.</p>
</dd>
<dt><strong>val</strong><span class="classifier">float or ndarray</span></dt><dd><p>Default value of the control at all nodes.  If val scalar and the control
is dynamic it will be broadcast.</p>
</dd>
<dt><strong>desc</strong><span class="classifier">str</span></dt><dd><p>A description of the polynomial control.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str or None or 0</span></dt><dd><p>Units in which the control variable is defined.  If 0, use the units declared
for the parameter in the ODE.</p>
</dd>
<dt><strong>opt</strong><span class="classifier">bool</span></dt><dd><p>If True (default) the value(s) of this control will be design variables in
the optimization problem, in the path ‘phase_name.indep_controls.controls:control_name’.
If False, the values of this control will exist as input controls:{name}</p>
</dd>
<dt><strong>fix_initial</strong><span class="classifier">bool</span></dt><dd><p>If True, the given initial value of the polynomial control is not a design variable and
will not be changed during the optimization.</p>
</dd>
<dt><strong>fix_final</strong><span class="classifier">bool</span></dt><dd><p>If True, the given final value of the polynomial control is not a design variable and
will not be changed during the optimization.</p>
</dd>
<dt><strong>lower</strong><span class="classifier">float or ndarray</span></dt><dd><p>The lower bound of the control at the nodes of the phase.</p>
</dd>
<dt><strong>upper</strong><span class="classifier">float or ndarray</span></dt><dd><p>The upper bound of the control at the nodes of the phase.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray</span></dt><dd><p>The scaler of the control value at the nodes of the phase.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray</span></dt><dd><p>The adder of the control value at the nodes of the phase.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or ndarray</span></dt><dd><p>The zero-reference value of the control at the nodes of the phase.</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray</span></dt><dd><p>The unit-reference value of the control at the nodes of the phase</p>
</dd>
<dt><strong>targets</strong><span class="classifier">Sequence of str or None</span></dt><dd><p>Targets in the ODE to which this polynomial control is connected.</p>
</dd>
<dt><strong>rate_targets</strong><span class="classifier">None or str</span></dt><dd><p>The name of the parameter in the ODE to which the first time-derivative
of the control value is connected.</p>
</dd>
<dt><strong>rate2_targets</strong><span class="classifier">None or str</span></dt><dd><p>The name of the parameter in the ODE to which the second time-derivative
of the control value is connected.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">Sequence of int</span></dt><dd><p>The shape of the control variable at each point in time.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_recorder">
<code class="sig-name descname">add_recorder</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">recorder</em>, <em class="sig-param">recurse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.add_recorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a recorder to the system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>recorder</strong><span class="classifier">&lt;CaseRecorder&gt;</span></dt><dd><p>A recorder instance.</p>
</dd>
<dt><strong>recurse</strong><span class="classifier">boolean</span></dt><dd><p>Flag indicating if the recorder should be added to all the subsystems.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_response">
<code class="sig-name descname">add_response</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">type_</em>, <em class="sig-param">lower=None</em>, <em class="sig-param">upper=None</em>, <em class="sig-param">equals=None</em>, <em class="sig-param">ref=None</em>, <em class="sig-param">ref0=None</em>, <em class="sig-param">indices=None</em>, <em class="sig-param">index=None</em>, <em class="sig-param">adder=None</em>, <em class="sig-param">scaler=None</em>, <em class="sig-param">linear=False</em>, <em class="sig-param">parallel_deriv_color=None</em>, <em class="sig-param">vectorize_derivs=False</em>, <em class="sig-param">cache_linear_solution=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.add_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a response variable to this system.</p>
<p>The response can be scaled using ref and ref0.
The argument <code class="code docutils literal notranslate"><span class="pre">ref0</span></code> represents the physical value when the scaled value is 0.
The argument <code class="code docutils literal notranslate"><span class="pre">ref</span></code> represents the physical value when the scaled value is 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>Name of the response variable in the system.</p>
</dd>
<dt><strong>type_</strong><span class="classifier">string</span></dt><dd><p>The type of response. Supported values are ‘con’ and ‘obj’</p>
</dd>
<dt><strong>lower</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Lower boundary for the variable</p>
</dd>
<dt><strong>upper</strong><span class="classifier">upper or ndarray, optional</span></dt><dd><p>Upper boundary for the variable</p>
</dd>
<dt><strong>equals</strong><span class="classifier">equals or ndarray, optional</span></dt><dd><p>Equality constraint value for the variable</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 1.0 in the driver.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">upper or ndarray, optional</span></dt><dd><p>Value of response variable that scales to 0.0 in the driver.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">sequence of int, optional</span></dt><dd><p>If variable is an array, these indicate which entries are of
interest for this particular response.</p>
</dd>
<dt><strong>index</strong><span class="classifier">int, optional</span></dt><dd><p>If variable is an array, this indicates which entry is of
interest for this particular response.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>Value to add to the model value to get the scaled value for the driver. adder
is first in precedence.  adder and scaler are an alterantive to using ref
and ref0.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray, optional</span></dt><dd><p>value to multiply the model value to get the scaled value for the driver. scaler
is second in precedence. adder and scaler are an alterantive to using ref
and ref0.</p>
</dd>
<dt><strong>linear</strong><span class="classifier">bool</span></dt><dd><p>Set to True if constraint is linear. Default is False.</p>
</dd>
<dt><strong>parallel_deriv_color</strong><span class="classifier">string</span></dt><dd><p>If specified, this design var will be grouped for parallel derivative
calculations with other variables sharing the same parallel_deriv_color.</p>
</dd>
<dt><strong>vectorize_derivs</strong><span class="classifier">bool</span></dt><dd><p>If True, vectorize derivative calculations.</p>
</dd>
<dt><strong>cache_linear_solution</strong><span class="classifier">bool</span></dt><dd><p>If True, store the linear solution vectors for this variable so they can
be used to start the next linear solution with an initial guess equal to the
solution from the previous linear solve.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_state">
<code class="sig-name descname">add_state</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">units=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">shape=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate_source=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">val=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_initial=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_final=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">lower=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">upper=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">adder=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref0=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">defect_scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">defect_ref=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">solve_segments=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">connected_initial=&lt;object object at 0x7f47d33f6670&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a state variable to be integrated by the phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of the state variable in the RHS.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str or None</span></dt><dd><p>Units in which the state variable is defined.  Internally components may use different
units for the state variable, but the IndepVarComp which provides its value will provide
it in these units, and collocation defects will use these units.  If units is not
specified here then the value as defined in the ODEOptions (&#64;dm.declare_state) will be
used.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple of int</span></dt><dd><p>The shape of the state variable.  For instance, a 3D cartesian position vector would have
a shape of (3,).</p>
</dd>
<dt><strong>rate_source</strong><span class="classifier">str</span></dt><dd><p>The path to the ODE output which provides the rate of this state variable.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">str or Sequence of str</span></dt><dd><p>The path to the targets of the state variable in the ODE system.  If given
this will override the value given by the &#64;declare_state decorator on the ODE.</p>
</dd>
<dt><strong>val</strong><span class="classifier">ndarray</span></dt><dd><p>The default value of the state at the state discretization nodes of the phase.</p>
</dd>
<dt><strong>fix_initial</strong><span class="classifier">bool(False)</span></dt><dd><p>If True, omit the first value of the state from the design variables (prevent the
optimizer from changing it).</p>
</dd>
<dt><strong>fix_final</strong><span class="classifier">bool(False)</span></dt><dd><p>If True, omit the final value of the state from the design variables (prevent the
optimizer from changing it).</p>
</dd>
<dt><strong>lower</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The lower bound of the state at the nodes of the phase.</p>
</dd>
<dt><strong>upper</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The upper bound of the state at the nodes of the phase.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The scaler of the state value at the nodes of the phase.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The adder of the state value at the nodes of the phase.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The zero-reference value of the state at the nodes of the phase.</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The unit-reference value of the state at the nodes of the phase</p>
</dd>
<dt><strong>defect_scaler</strong><span class="classifier">float or ndarray</span></dt><dd><p>The scaler of the state defect at the collocation nodes of the phase.</p>
</dd>
<dt><strong>defect_ref</strong><span class="classifier">float or ndarray</span></dt><dd><p>The unit-reference value of the state defect at the collocation nodes of the phase. If
provided, this value overrides defect_scaler.</p>
</dd>
<dt><strong>solve_segments</strong><span class="classifier">bool(False)</span></dt><dd><p>If True, a solver will be used to converge the collocation defects within a segment.
Note that the state continuity defects between segements will still be
handled by the optimizer.</p>
</dd>
<dt><strong>connected_initial</strong><span class="classifier">bool</span></dt><dd><p>If True, then the initial value for this state comes from an externally connected
source.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_subsystem">
<code class="sig-name descname">add_subsystem</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">subsys</em>, <em class="sig-param">promotes=None</em>, <em class="sig-param">promotes_inputs=None</em>, <em class="sig-param">promotes_outputs=None</em>, <em class="sig-param">min_procs=1</em>, <em class="sig-param">max_procs=None</em>, <em class="sig-param">proc_weight=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.add_subsystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a subsystem.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of the subsystem being added</p>
</dd>
<dt><strong>subsys</strong><span class="classifier">&lt;System&gt;</span></dt><dd><p>An instantiated, but not-yet-set up system object.</p>
</dd>
<dt><strong>promotes</strong><span class="classifier">iter of (str or tuple), optional</span></dt><dd><p>A list of variable names specifying which subsystem variables
to ‘promote’ up to this group. If an entry is a tuple of the
form (old_name, new_name), this will rename the variable in
the parent group.</p>
</dd>
<dt><strong>promotes_inputs</strong><span class="classifier">iter of (str or tuple), optional</span></dt><dd><p>A list of input variable names specifying which subsystem input
variables to ‘promote’ up to this group. If an entry is a tuple of
the form (old_name, new_name), this will rename the variable in
the parent group.</p>
</dd>
<dt><strong>promotes_outputs</strong><span class="classifier">iter of (str or tuple), optional</span></dt><dd><p>A list of output variable names specifying which subsystem output
variables to ‘promote’ up to this group. If an entry is a tuple of
the form (old_name, new_name), this will rename the variable in
the parent group.</p>
</dd>
<dt><strong>min_procs</strong><span class="classifier">int</span></dt><dd><p>Minimum number of MPI processes usable by the subsystem. Defaults to 1.</p>
</dd>
<dt><strong>max_procs</strong><span class="classifier">int or None</span></dt><dd><p>Maximum number of MPI processes usable by the subsystem.  A value
of None (the default) indicates there is no maximum limit.</p>
</dd>
<dt><strong>proc_weight</strong><span class="classifier">float</span></dt><dd><p>Weight given to the subsystem when allocating available MPI processes
to all subsystems.  Default is 1.0.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>&lt;System&gt;</strong><span class="classifier"></span></dt><dd><p>the subsystem that was passed in. This is returned to
enable users to instantiate and add a subsystem at the
same time, and get the reference back.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_timeseries">
<code class="sig-name descname">add_timeseries</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">transcription</em>, <em class="sig-param">subset='all'</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_timeseries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_timeseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new timeseries output upon which outputs can be provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>A name for the timeseries output path.</p>
</dd>
<dt><strong>transcription</strong><span class="classifier">str</span></dt><dd><p>A transcription object which provides a grid upon which the outputs of the timeseries
are provided.</p>
</dd>
<dt><strong>subset</strong><span class="classifier">str</span></dt><dd><p>The name of the node subset in the given transcription at which outputs
are to be provided.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.add_timeseries_output">
<code class="sig-name descname">add_timeseries_output</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">output_name=None</em>, <em class="sig-param">units=None</em>, <em class="sig-param">shape=(1</em>, <em class="sig-param">)</em>, <em class="sig-param">timeseries='timeseries'</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.add_timeseries_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.add_timeseries_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a variable to the timeseries outputs of the phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">string</span></dt><dd><p>The name of the variable to be used as a timeseries output.  Must be one of
‘time’, ‘time_phase’, one of the states, controls, control rates, or parameters,
in the phase, or the path to an output variable in the ODE.</p>
</dd>
<dt><strong>output_name</strong><span class="classifier">string or None</span></dt><dd><p>The name of the variable as listed in the phase timeseries outputs.  By
default this is the last element in <cite>name</cite> when split by dots.  The user may
override the constraint name if splitting the path causes name collisions.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str or None</span></dt><dd><p>The units in which the boundary constraint is to be applied.  If None, use the
units associated with the constrained output.  If provided, must be compatible with
the variables units.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the timeseries output variable.  This must be provided (if not scalar)
since Dymos doesn’t necessarily know the shape of ODE outputs until setup time.</p>
</dd>
<dt><strong>timeseries</strong><span class="classifier">str or None</span></dt><dd><p>The name of the timeseries to which the output is being added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.approx_totals">
<code class="sig-name descname">approx_totals</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">method='fd'</em>, <em class="sig-param">step=None</em>, <em class="sig-param">form=None</em>, <em class="sig-param">step_calc=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.approx_totals" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate derivatives for a Group using the specified approximation method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>The type of approximation that should be used. Valid options include:
‘fd’: Finite Difference, ‘cs’: Complex Step</p>
</dd>
<dt><strong>step</strong><span class="classifier">float</span></dt><dd><p>Step size for approximation. Defaults to None, in which case, the approximation
method provides its default value.</p>
</dd>
<dt><strong>form</strong><span class="classifier">string</span></dt><dd><p>Form for finite difference, can be ‘forward’, ‘backward’, or ‘central’. Defaults to
None, in which case, the approximation method provides its default value.</p>
</dd>
<dt><strong>step_calc</strong><span class="classifier">string</span></dt><dd><p>Step type for finite difference, can be ‘abs’ for absolute’, or ‘rel’ for
relative. Defaults to None, in which case, the approximation method
provides its default value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.check_config">
<code class="sig-name descname">check_config</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">logger</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.check_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.check_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Print warnings associated with the Phase if check is enabled during setup.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>logger</strong></dt><dd><p>The logger object to which warnings and errors will be sent.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.check_parameter">
<code class="sig-name descname">check_parameter</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.check_parameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.check_parameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks that the parameter of the given name is valid.</p>
<p>First name is checked against all existing controls, input parameters, and design
parameters.  If it has already been assigned to one of those, ValueError is raised.
Finally, if <em>dynamic</em> is True, the control is not a dynamic parameter in the ODE,
ValueError is raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the controllable parameter.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ValueError</strong></dt><dd><p>Raised if the parameter of the given name is previously assigned or
incompatible with the type of control to which it is assigned.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.check_time_options">
<code class="sig-name descname">check_time_options</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.check_time_options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.check_time_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that time options are valid and issue warnings if invalid options are provided.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<dl class="simple">
<dt>RuntimeWarning</dt><dd><p>RuntimeWarning is issued in the case of one or more invalid time options.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.classify_var">
<code class="sig-name descname">classify_var</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">var</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.classify_var"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.classify_var" title="Permalink to this definition">¶</a></dt>
<dd><p>Classifies a variable of the given name or path.</p>
<p>This method searches for it as a time variable, state variable,
control variable, or parameter.  If it is not found to be one
of those variables, it is assumed to be the path to a variable
relative to the top of the ODE system for the phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>var</strong><span class="classifier">str</span></dt><dd><p>The name of the variable to be classified.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>str</strong><span class="classifier"></span></dt><dd><p>The classification of the given variable, which is one of
‘time’, ‘state’, ‘input_control’, ‘indep_control’, ‘control_rate’,
‘control_rate2’, ‘input_polynomial_control’, ‘indep_polynomial_control’,
‘polynomial_control_rate’, ‘polynomial_control_rate2’, ‘design_parameter’,
‘input_parameter’, or ‘ode’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.cleanup">
<code class="sig-name descname">cleanup</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up resources prior to exit.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.compute_sys_graph">
<code class="sig-name descname">compute_sys_graph</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">comps_only=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.compute_sys_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a dependency graph for subsystems in this group.</p>
<p>Variable connection information is stored in each edge of
the system graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>comps_only</strong><span class="classifier">bool (False)</span></dt><dd><p>If True, return a graph of all components within this group
or any of its descendants. No sub-groups will be included. Otherwise,
a graph containing only direct children (both Components and Groups)
of this group will be returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>DiGraph</strong><span class="classifier"></span></dt><dd><p>A directed graph containing names of subsystems and their connections.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.configure">
<code class="sig-name descname">configure</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure this group to assign children settings.</p>
<p>This method may optionally be overidden by your Group’s method.</p>
<p>You may only use this method to change settings on your children subsystems. This includes
setting solvers in cases where you want to override the defaults.</p>
<p>You can assume that the full hierarchy below your level has been instantiated and has
already called its own configure methods.</p>
<dl class="simple">
<dt>Available attributes:</dt><dd><p>name
pathname
comm
options
system hieararchy with attribute access</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.connect">
<code class="sig-name descname">connect</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">src_name</em>, <em class="sig-param">tgt_name</em>, <em class="sig-param">src_indices=None</em>, <em class="sig-param">flat_src_indices=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect source src_name to target tgt_name in this namespace.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src_name</strong><span class="classifier">str</span></dt><dd><p>name of the source variable to connect</p>
</dd>
<dt><strong>tgt_name</strong><span class="classifier">str or [str, … ] or (str, …)</span></dt><dd><p>name of the target variable(s) to connect</p>
</dd>
<dt><strong>src_indices</strong><span class="classifier">int or list of ints or tuple of ints or int ndarray or Iterable or None</span></dt><dd><p>The global indices of the source variable to transfer data from.
The shapes of the target and src_indices must match, and form of the
entries within is determined by the value of ‘flat_src_indices’.</p>
</dd>
<dt><strong>flat_src_indices</strong><span class="classifier">bool</span></dt><dd><p>If True, each entry of src_indices is assumed to be an index into the
flattened source.  Otherwise it must be a tuple or list of size equal
to the number of dimensions of the source.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.convert2units">
<code class="sig-name descname">convert2units</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">val</em>, <em class="sig-param">units</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.convert2units" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the given value to the specified units.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of the variable.</p>
</dd>
<dt><strong>val</strong><span class="classifier">float or ndarray of float</span></dt><dd><p>The value of the variable.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str</span></dt><dd><p>The units to convert to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>float or ndarray of float</strong><span class="classifier"></span></dt><dd><p>The value converted to the specified units.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.declare_coloring">
<code class="sig-name descname">declare_coloring</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">wrt=('*'</em>, <em class="sig-param">)</em>, <em class="sig-param">method='fd'</em>, <em class="sig-param">form=None</em>, <em class="sig-param">step=None</em>, <em class="sig-param">per_instance=True</em>, <em class="sig-param">num_full_jacs=3</em>, <em class="sig-param">tol=1e-25</em>, <em class="sig-param">orders=None</em>, <em class="sig-param">perturb_size=1e-09</em>, <em class="sig-param">min_improve_pct=5.0</em>, <em class="sig-param">show_summary=True</em>, <em class="sig-param">show_sparsity=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.declare_coloring" title="Permalink to this definition">¶</a></dt>
<dd><p>Set options for deriv coloring of a set of wrt vars matching the given pattern(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>wrt</strong><span class="classifier">str or list of str</span></dt><dd><p>The name or names of the variables that derivatives are taken with respect to.
This can contain input names, output names, or glob patterns.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>Method used to compute derivative: “fd” for finite difference, “cs” for complex step.</p>
</dd>
<dt><strong>form</strong><span class="classifier">str</span></dt><dd><p>Finite difference form, can be “forward”, “central”, or “backward”. Leave
undeclared to keep unchanged from previous or default value.</p>
</dd>
<dt><strong>step</strong><span class="classifier">float</span></dt><dd><p>Step size for finite difference. Leave undeclared to keep unchanged from previous
or default value.</p>
</dd>
<dt><strong>per_instance</strong><span class="classifier">bool</span></dt><dd><p>If True, a separate coloring will be generated for each instance of a given class.
Otherwise, only one coloring for a given class will be generated and all instances
of that class will use it.</p>
</dd>
<dt><strong>num_full_jacs</strong><span class="classifier">int</span></dt><dd><p>Number of times to repeat partial jacobian computation when computing sparsity.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float</span></dt><dd><p>Tolerance used to determine if an array entry is nonzero during sparsity determination.</p>
</dd>
<dt><strong>orders</strong><span class="classifier">int</span></dt><dd><p>Number of orders above and below the tolerance to check during the tolerance sweep.</p>
</dd>
<dt><strong>perturb_size</strong><span class="classifier">float</span></dt><dd><p>Size of input/output perturbation during generation of sparsity.</p>
</dd>
<dt><strong>min_improve_pct</strong><span class="classifier">float</span></dt><dd><p>If coloring does not improve (decrease) the number of solves more than the given
percentage, coloring will not be used.</p>
</dd>
<dt><strong>show_summary</strong><span class="classifier">bool</span></dt><dd><p>If True, display summary information after generating coloring.</p>
</dd>
<dt><strong>show_sparsity</strong><span class="classifier">bool</span></dt><dd><p>If True, display sparsity with coloring info after generating coloring.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.finalize_variables">
<code class="sig-name descname">finalize_variables</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.finalize_variables"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.finalize_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalize the variable options by combining the user-defined options and the ODE options.</p>
<p>First apply any variable options that may be defined via ODEOptions properties on the ODE
class.  Then apply any user-specified options over those.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.get_approx_coloring_fname">
<code class="sig-name descname">get_approx_coloring_fname</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.get_approx_coloring_fname" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full pathname to a coloring file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>system</strong><span class="classifier">System</span></dt><dd><p>The System having its coloring saved or loaded.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>str</strong><span class="classifier"></span></dt><dd><p>Full pathname of the coloring file.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.get_constraints">
<code class="sig-name descname">get_constraints</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">recurse=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.get_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Constraint settings from this system.</p>
<p>Retrieve the constraint settings for the current system as a dict,
keyed by variable name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>recurse</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, recurse through the subsystems and return the path of
all constraints relative to the this system.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dict</strong><span class="classifier"></span></dt><dd><p>The constraints defined in the current system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.get_design_vars">
<code class="sig-name descname">get_design_vars</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">recurse=True</em>, <em class="sig-param">get_sizes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.get_design_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the DesignVariable settings from this system.</p>
<p>Retrieve all design variable settings from the system and, if recurse
is True, all of its subsystems.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>recurse</strong><span class="classifier">bool</span></dt><dd><p>If True, recurse through the subsystems and return the path of
all design vars relative to the this system.</p>
</dd>
<dt><strong>get_sizes</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, compute the size of each design variable.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dict</strong><span class="classifier"></span></dt><dd><p>The design variables defined in the current system and, if
recurse=True, its subsystems.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.get_linear_vectors">
<code class="sig-name descname">get_linear_vectors</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vec_name='linear'</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.get_linear_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the linear inputs, outputs, and residuals vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vec_name</strong><span class="classifier">str</span></dt><dd><p>Name of the linear right-hand-side vector. The default is ‘linear’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>(inputs, outputs, residuals)</strong><span class="classifier">tuple of &lt;Vector&gt; instances</span></dt><dd><p>Yields the inputs, outputs, and residuals linear vectors for vec_name.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.get_nonlinear_vectors">
<code class="sig-name descname">get_nonlinear_vectors</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.get_nonlinear_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the inputs, outputs, and residuals vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>(inputs, outputs, residuals)</strong><span class="classifier">tuple of &lt;Vector&gt; instances</span></dt><dd><p>Yields the inputs, outputs, and residuals nonlinear vectors.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.get_objectives">
<code class="sig-name descname">get_objectives</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">recurse=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.get_objectives" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Objective settings from this system.</p>
<p>Retrieve all objectives settings from the system as a dict, keyed
by variable name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>recurse</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, recurse through the subsystems and return the path of
all objective relative to the this system.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dict</strong><span class="classifier"></span></dt><dd><p>The objectives defined in the current system.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.get_responses">
<code class="sig-name descname">get_responses</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">recurse=True</em>, <em class="sig-param">get_sizes=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.get_responses" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the response variable settings from this system.</p>
<p>Retrieve all response variable settings from the system as a dict,
keyed by variable name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>recurse</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, recurse through the subsystems and return the path of
all responses relative to the this system.</p>
</dd>
<dt><strong>get_sizes</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, compute the size of each response.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dict</strong><span class="classifier"></span></dt><dd><p>The responses defined in the current system and, if
recurse=True, its subsystems.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.get_simulation_phase">
<code class="sig-name descname">get_simulation_phase</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">times_per_seg=None</em>, <em class="sig-param">method='RK45'</em>, <em class="sig-param">atol=1e-09</em>, <em class="sig-param">rtol=1e-09</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.get_simulation_phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.get_simulation_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a SolveIVPPhase initialized based on data from this Phase instance and
the given simulation times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times_per_seg</strong><span class="classifier">int or None</span></dt><dd><p>Number of equally distributed output times per segment in the phase simulation.  If
None, output to all nodes provided by this phases GridData.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>The scipy.integrate.solve_ivp integration method.</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Absolute convergence tolerance for the scipy.integrate.solve_ivp method.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float</span></dt><dd><p>Relative convergence tolerance for the scipy.integrate.solve_ivp method.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>SimulationPhase</strong><span class="classifier"></span></dt><dd><p>An instance of SimulationPhase initialized based on data from this Phase and the given
times.  This instance has not yet been setup.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.guess_nonlinear">
<code class="sig-name descname">guess_nonlinear</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">inputs</em>, <em class="sig-param">outputs</em>, <em class="sig-param">residuals</em>, <em class="sig-param">discrete_inputs=None</em>, <em class="sig-param">discrete_outputs=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.guess_nonlinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide initial guess for states.</p>
<p>Override this method to set the initial guess for states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inputs</strong><span class="classifier">Vector</span></dt><dd><p>unscaled, dimensional input variables read via inputs[key]</p>
</dd>
<dt><strong>outputs</strong><span class="classifier">Vector</span></dt><dd><p>unscaled, dimensional output variables read via outputs[key]</p>
</dd>
<dt><strong>residuals</strong><span class="classifier">Vector</span></dt><dd><p>unscaled, dimensional residuals written to via residuals[key]</p>
</dd>
<dt><strong>discrete_inputs</strong><span class="classifier">dict or None</span></dt><dd><p>If not None, dict containing discrete input values.</p>
</dd>
<dt><strong>discrete_outputs</strong><span class="classifier">dict or None</span></dt><dd><p>If not None, dict containing discrete output values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.initialize">
<code class="sig-name descname">initialize</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform any one-time initialization run at instantiation.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.initialize_values_from_phase">
<code class="sig-name descname">initialize_values_from_phase</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">prob</em>, <em class="sig-param">from_phase</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.initialize_values_from_phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.initialize_values_from_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes values in the Phase using the phase from which it was created.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>prob</strong><span class="classifier">Problem</span></dt><dd><p>The problem instance under used to set values in this phase instance.</p>
</dd>
<dt><strong>from_phase</strong><span class="classifier">Phase</span></dt><dd><p>The Phase instance from which the values in this phase are being initialized.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.interpolate">
<code class="sig-name descname">interpolate</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">xs=None</em>, <em class="sig-param">ys=None</em>, <em class="sig-param">nodes='all'</em>, <em class="sig-param">kind='linear'</em>, <em class="sig-param">axis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.interpolate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of values on interpolated to the given node subset of the phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xs</strong><span class="classifier">ndarray or Sequence or None</span></dt><dd><p>Array of integration variable values.</p>
</dd>
<dt><strong>ys</strong><span class="classifier">ndarray or Sequence or None</span></dt><dd><p>Array of control/state/parameter values.</p>
</dd>
<dt><strong>nodes</strong><span class="classifier">str or None</span></dt><dd><p>The name of the node subset or None (default).</p>
</dd>
<dt><strong>kind</strong><span class="classifier">str</span></dt><dd><p>Specifies the kind of interpolation, as per the scipy.interpolate package.
One of (‘linear’, ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’
where ‘zero’, ‘slinear’, ‘quadratic’ and ‘cubic’ refer to a spline
interpolation of zeroth, first, second or third order) or as an
integer specifying the order of the spline interpolator to use.
Default is ‘linear’.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>Specifies the axis along which interpolation should be performed.  Default is
the first axis (0).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>np.array</strong><span class="classifier"></span></dt><dd><p>The values of y interpolated at nodes of the specified type.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.is_active">
<code class="sig-name descname">is_active</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.is_active" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if the system is active on this rank.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bool</strong><span class="classifier"></span></dt><dd><p>If running under MPI, returns True if this <cite>System</cite> has a valid
communicator. Always returns True if not running under MPI.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.linear_solver">
<em class="property">property </em><code class="sig-name descname">linear_solver</code><a class="headerlink" href="#dymos.phase.phase.Phase.linear_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the linear solver for this system.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.list_inputs">
<code class="sig-name descname">list_inputs</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">values=True</em>, <em class="sig-param">prom_name=False</em>, <em class="sig-param">units=False</em>, <em class="sig-param">shape=False</em>, <em class="sig-param">desc=False</em>, <em class="sig-param">hierarchical=True</em>, <em class="sig-param">print_arrays=False</em>, <em class="sig-param">tags=None</em>, <em class="sig-param">includes=None</em>, <em class="sig-param">excludes=None</em>, <em class="sig-param">out_stream=&lt;object object at 0x7f47d33f61d0&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.list_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return and optionally log a list of input names and other optional information.</p>
<p>If the model is parallel, only the local variables are returned to the process.
Also optionally logs the information to a user defined output stream. If the model is
parallel, the rank 0 process logs information about all variables across all processes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return input values. Default is True.</p>
</dd>
<dt><strong>prom_name</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return the promoted name of the variable.
Default is False.</p>
</dd>
<dt><strong>units</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return units. Default is False.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return the shape of the value. Default is False.</p>
</dd>
<dt><strong>desc</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return description. Default is False.</p>
</dd>
<dt><strong>hierarchical</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, human readable output shows variables in hierarchical format.</p>
</dd>
<dt><strong>print_arrays</strong><span class="classifier">bool, optional</span></dt><dd><p>When False, in the columnar display, just display norm of any ndarrays with size &gt; 1.
The norm is surrounded by vertical bars to indicate that it is a norm.
When True, also display full values of the ndarray below the row. Format is affected
by the values set with numpy.set_printoptions
Default is False.</p>
</dd>
<dt><strong>tags</strong><span class="classifier">str or list of strs</span></dt><dd><p>User defined tags that can be used to filter what gets listed. Only inputs with the
given tags will be listed.
Default is None, which means there will be no filtering based on tags.</p>
</dd>
<dt><strong>includes</strong><span class="classifier">None or list_like</span></dt><dd><p>List of glob patterns for pathnames to include in the check. Default is None, which
includes all components in the model.</p>
</dd>
<dt><strong>excludes</strong><span class="classifier">None or list_like</span></dt><dd><p>List of glob patterns for pathnames to exclude from the check. Default is None, which
excludes nothing.</p>
</dd>
<dt><strong>out_stream</strong><span class="classifier">file-like object</span></dt><dd><p>Where to send human readable output. Default is sys.stdout.
Set to None to suppress.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>list</strong><span class="classifier"></span></dt><dd><p>list of input names and other optional information about those inputs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.list_outputs">
<code class="sig-name descname">list_outputs</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">explicit=True</em>, <em class="sig-param">implicit=True</em>, <em class="sig-param">values=True</em>, <em class="sig-param">prom_name=False</em>, <em class="sig-param">residuals=False</em>, <em class="sig-param">residuals_tol=None</em>, <em class="sig-param">units=False</em>, <em class="sig-param">shape=False</em>, <em class="sig-param">bounds=False</em>, <em class="sig-param">scaling=False</em>, <em class="sig-param">desc=False</em>, <em class="sig-param">hierarchical=True</em>, <em class="sig-param">print_arrays=False</em>, <em class="sig-param">tags=None</em>, <em class="sig-param">includes=None</em>, <em class="sig-param">excludes=None</em>, <em class="sig-param">out_stream=&lt;object object at 0x7f47d33f61d0&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.list_outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Return and optionally log a list of output names and other optional information.</p>
<p>If the model is parallel, only the local variables are returned to the process.
Also optionally logs the information to a user defined output stream. If the model is
parallel, the rank 0 process logs information about all variables across all processes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>explicit</strong><span class="classifier">bool, optional</span></dt><dd><p>include outputs from explicit components. Default is True.</p>
</dd>
<dt><strong>implicit</strong><span class="classifier">bool, optional</span></dt><dd><p>include outputs from implicit components. Default is True.</p>
</dd>
<dt><strong>values</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return output values. Default is True.</p>
</dd>
<dt><strong>prom_name</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return the promoted name of the variable.
Default is False.</p>
</dd>
<dt><strong>residuals</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return residual values. Default is False.</p>
</dd>
<dt><strong>residuals_tol</strong><span class="classifier">float, optional</span></dt><dd><p>If set, limits the output of list_outputs to only variables where
the norm of the resids array is greater than the given ‘residuals_tol’.
Default is None.</p>
</dd>
<dt><strong>units</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return units. Default is False.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return the shape of the value. Default is False.</p>
</dd>
<dt><strong>bounds</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return bounds (lower and upper). Default is False.</p>
</dd>
<dt><strong>scaling</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return scaling (ref, ref0, and res_ref). Default is False.</p>
</dd>
<dt><strong>desc</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, display/return description. Default is False.</p>
</dd>
<dt><strong>hierarchical</strong><span class="classifier">bool, optional</span></dt><dd><p>When True, human readable output shows variables in hierarchical format.</p>
</dd>
<dt><strong>print_arrays</strong><span class="classifier">bool, optional</span></dt><dd><p>When False, in the columnar display, just display norm of any ndarrays with size &gt; 1.
The norm is surrounded by vertical bars to indicate that it is a norm.
When True, also display full values of the ndarray below the row. Format  is affected
by the values set with numpy.set_printoptions
Default is False.</p>
</dd>
<dt><strong>tags</strong><span class="classifier">str or list of strs</span></dt><dd><p>User defined tags that can be used to filter what gets listed. Only outputs with the
given tags will be listed.
Default is None, which means there will be no filtering based on tags.</p>
</dd>
<dt><strong>includes</strong><span class="classifier">None or list_like</span></dt><dd><p>List of glob patterns for pathnames to include in the check. Default is None, which
includes all components in the model.</p>
</dd>
<dt><strong>excludes</strong><span class="classifier">None or list_like</span></dt><dd><p>List of glob patterns for pathnames to exclude from the check. Default is None, which
excludes nothing.</p>
</dd>
<dt><strong>out_stream</strong><span class="classifier">file-like</span></dt><dd><p>Where to send human readable output. Default is sys.stdout.
Set to None to suppress.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>list</strong><span class="classifier"></span></dt><dd><p>list of output names and other optional information about those outputs</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.ln_solver">
<em class="property">property </em><code class="sig-name descname">ln_solver</code><a class="headerlink" href="#dymos.phase.phase.Phase.ln_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the linear solver for this system.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.metadata">
<em class="property">property </em><code class="sig-name descname">metadata</code><a class="headerlink" href="#dymos.phase.phase.Phase.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the options for this System.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.msginfo">
<em class="property">property </em><code class="sig-name descname">msginfo</code><a class="headerlink" href="#dymos.phase.phase.Phase.msginfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Our instance pathname, if available, or our class name.  For use in error messages.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>str</strong><span class="classifier"></span></dt><dd><p>Either our instance pathname or class name.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.nl_solver">
<em class="property">property </em><code class="sig-name descname">nl_solver</code><a class="headerlink" href="#dymos.phase.phase.Phase.nl_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nonlinear solver for this system.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.nonlinear_solver">
<em class="property">property </em><code class="sig-name descname">nonlinear_solver</code><a class="headerlink" href="#dymos.phase.phase.Phase.nonlinear_solver" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the nonlinear solver for this system.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.reconfigure">
<code class="sig-name descname">reconfigure</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.reconfigure" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform reconfiguration.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bool</strong><span class="classifier"></span></dt><dd><p>If True, reconfiguration is to be performed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.record_iteration">
<code class="sig-name descname">record_iteration</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.record_iteration" title="Permalink to this definition">¶</a></dt>
<dd><p>Record an iteration of the current System.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.resetup">
<code class="sig-name descname">resetup</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">setup_mode='full'</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.resetup" title="Permalink to this definition">¶</a></dt>
<dd><p>Public wrapper for _setup that reconfigures after an initial setup has been performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>setup_mode</strong><span class="classifier">str</span></dt><dd><p>Must be one of ‘full’, ‘reconf’, or ‘update’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.run_apply_linear">
<code class="sig-name descname">run_apply_linear</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vec_names</em>, <em class="sig-param">mode</em>, <em class="sig-param">scope_out=None</em>, <em class="sig-param">scope_in=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.run_apply_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute jac-vec product.</p>
<p>This calls _apply_linear, but with the model assumed to be in an unscaled state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vec_names</strong><span class="classifier">[str, …]</span></dt><dd><p>list of names of the right-hand-side vectors.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>‘fwd’ or ‘rev’.</p>
</dd>
<dt><strong>scope_out</strong><span class="classifier">set or None</span></dt><dd><p>Set of absolute output names in the scope of this mat-vec product.
If None, all are in the scope.</p>
</dd>
<dt><strong>scope_in</strong><span class="classifier">set or None</span></dt><dd><p>Set of absolute input names in the scope of this mat-vec product.
If None, all are in the scope.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.run_apply_nonlinear">
<code class="sig-name descname">run_apply_nonlinear</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.run_apply_nonlinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute residuals.</p>
<p>This calls _apply_nonlinear, but with the model assumed to be in an unscaled state.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.run_linearize">
<code class="sig-name descname">run_linearize</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">sub_do_ln=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.run_linearize" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute jacobian / factorization.</p>
<p>This calls _linearize, but with the model assumed to be in an unscaled state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sub_do_ln</strong><span class="classifier">boolean</span></dt><dd><p>Flag indicating if the children should call linearize on their linear solvers.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.run_solve_linear">
<code class="sig-name descname">run_solve_linear</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">vec_names</em>, <em class="sig-param">mode</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.run_solve_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply inverse jac product.</p>
<p>This calls _solve_linear, but with the model assumed to be in an unscaled state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>vec_names</strong><span class="classifier">[str, …]</span></dt><dd><p>list of names of the right-hand-side vectors.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str</span></dt><dd><p>‘fwd’ or ‘rev’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.run_solve_nonlinear">
<code class="sig-name descname">run_solve_nonlinear</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.run_solve_nonlinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute outputs.</p>
<p>This calls _solve_nonlinear, but with the model assumed to be in an unscaled state.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.set_initial_values">
<code class="sig-name descname">set_initial_values</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.set_initial_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all input and output variables to their declared initial values.</p>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.set_order">
<code class="sig-name descname">set_order</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">new_order</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.set_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify a new execution order for this system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>new_order</strong><span class="classifier">list of str</span></dt><dd><p>List of system names in desired new execution order.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.set_refine_options">
<code class="sig-name descname">set_refine_options</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">refine=False</em>, <em class="sig-param">iteration_limit=10</em>, <em class="sig-param">tol=0.0001</em>, <em class="sig-param">min_order=3</em>, <em class="sig-param">max_order=14</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.set_refine_options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.set_refine_options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.set_state_options">
<code class="sig-name descname">set_state_options</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em>, <em class="sig-param">units=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">shape=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">rate_source=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">val=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_initial=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_final=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">lower=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">upper=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">adder=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref0=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">ref=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">defect_scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">defect_ref=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">solve_segments=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">connected_initial=&lt;object object at 0x7f47d33f6670&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.set_state_options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.set_state_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Set options that apply the EOM state variable of the given name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of the state variable in the RHS.</p>
</dd>
<dt><strong>units</strong><span class="classifier">str or None</span></dt><dd><p>Units in which the state variable is defined.  Internally components may use different
units for the state variable, but the IndepVarComp which provides its value will provide
it in these units, and collocation defects will use these units.  If units is not
specified here then the value as defined in the ODEOptions (&#64;dm.declare_state) will be
used.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple of int</span></dt><dd><p>The shape of the state variable.  For instance, a 3D cartesian position vector would have
a shape of (3,).</p>
</dd>
<dt><strong>rate_source</strong><span class="classifier">str</span></dt><dd><p>The path to the ODE output which provides the rate of this state variable.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">str or Sequence of str</span></dt><dd><p>The path to the targets of the state variable in the ODE system.  If given
this will override the value given by the &#64;declare_state decorator on the ODE.</p>
</dd>
<dt><strong>val</strong><span class="classifier">ndarray</span></dt><dd><p>The default value of the state at the state discretization nodes of the phase.</p>
</dd>
<dt><strong>fix_initial</strong><span class="classifier">bool(False)</span></dt><dd><p>If True, omit the first value of the state from the design variables (prevent the
optimizer from changing it).</p>
</dd>
<dt><strong>fix_final</strong><span class="classifier">bool(False)</span></dt><dd><p>If True, omit the final value of the state from the design variables (prevent the
optimizer from changing it).</p>
</dd>
<dt><strong>lower</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The lower bound of the state at the nodes of the phase.</p>
</dd>
<dt><strong>upper</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The upper bound of the state at the nodes of the phase.</p>
</dd>
<dt><strong>scaler</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The scaler of the state value at the nodes of the phase.</p>
</dd>
<dt><strong>adder</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The adder of the state value at the nodes of the phase.</p>
</dd>
<dt><strong>ref0</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The zero-reference value of the state at the nodes of the phase.</p>
</dd>
<dt><strong>ref</strong><span class="classifier">float or ndarray or None (None)</span></dt><dd><p>The unit-reference value of the state at the nodes of the phase</p>
</dd>
<dt><strong>defect_scaler</strong><span class="classifier">float or ndarray</span></dt><dd><p>The scaler of the state defect at the collocation nodes of the phase.</p>
</dd>
<dt><strong>defect_ref</strong><span class="classifier">float or ndarray</span></dt><dd><p>The unit-reference value of the state defect at the collocation nodes of the phase. If
provided, this value overrides defect_scaler.</p>
</dd>
<dt><strong>solve_segments</strong><span class="classifier">bool(False)</span></dt><dd><p>If True, a solver will be used to converge the collocation defects within a segment.
Note that the state continuity defects between segements will still be
handled by the optimizer.</p>
</dd>
<dt><strong>connected_initial</strong><span class="classifier">bool</span></dt><dd><p>If True, then the initial value for this state comes from an externally connected
source.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.set_time_options">
<code class="sig-name descname">set_time_options</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">units=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_initial=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">fix_duration=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">input_initial=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">input_duration=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">initial_val=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">initial_bounds=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">initial_scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">initial_adder=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">initial_ref0=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">initial_ref=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">duration_val=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">duration_bounds=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">duration_scaler=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">duration_adder=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">duration_ref0=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">duration_ref=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">time_phase_targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">t_initial_targets=&lt;object object at 0x7f47d33f6670&gt;</em>, <em class="sig-param">t_duration_targets=&lt;object object at 0x7f47d33f6670&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.set_time_options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.set_time_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets options for time in the phase.  Only those options which are specified in the
arguments will be updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>units</strong><span class="classifier">str</span></dt><dd><p>The default units for time variables in the phase.  Default is ‘s’.</p>
</dd>
<dt><strong>fix_initial</strong><span class="classifier">bool</span></dt><dd><p>If True, the initial time of the phase is not treated as a design variable for the
optimization problem.</p>
</dd>
<dt><strong>fix_duration</strong><span class="classifier">bool</span></dt><dd><p>If True, the duration of the phase is not treated as a design variable for the
optimization problem.</p>
</dd>
<dt><strong>input_initial</strong><span class="classifier">bool</span></dt><dd><p>If True, the user is expected to link phase.t_initial to an external output source.
Providing input_initial=True makes all initial time optimization settings irrelevant.</p>
</dd>
<dt><strong>input_duration</strong><span class="classifier">bool</span></dt><dd><p>If True, the user is expected to link phase.t_duration to an external output source.
Providing input_duration=True makes all time duration optimization settings irrelevant.</p>
</dd>
<dt><strong>initial_val</strong><span class="classifier">float</span></dt><dd><p>Default value of the time at the start of the phase.</p>
</dd>
<dt><strong>initial_bounds</strong><span class="classifier">iterable of (float, float)</span></dt><dd><p>The bounds (lower, upper) for time at the start of the phase.</p>
</dd>
<dt><strong>initial_scaler</strong><span class="classifier">float</span></dt><dd><p>Scalar for the initial value of time.</p>
</dd>
<dt><strong>initial_adder</strong><span class="classifier">float</span></dt><dd><p>Adder for the initial value of time.</p>
</dd>
<dt><strong>initial_ref0</strong><span class="classifier">float</span></dt><dd><p>Zero-reference for the initial value of time</p>
</dd>
<dt><strong>initial_ref</strong><span class="classifier">float</span></dt><dd><p>Unit-reference for the initial value of time.</p>
</dd>
<dt><strong>duration_val</strong><span class="classifier">float</span></dt><dd><p>Default value for the time duration of the phase.</p>
</dd>
<dt><strong>duration_bounds</strong><span class="classifier">iterable of (float, float)</span></dt><dd><p>The bounds (lower, upper) for the time duration of the phase.</p>
</dd>
<dt><strong>duration_scaler</strong><span class="classifier">float</span></dt><dd><p>Scaler for phase time duration.</p>
</dd>
<dt><strong>duration_adder</strong><span class="classifier">float</span></dt><dd><p>Adder for phase time duration.</p>
</dd>
<dt><strong>duration_ref0</strong><span class="classifier">float</span></dt><dd><p>Zero-reference for phase time duration.</p>
</dd>
<dt><strong>duration_ref</strong><span class="classifier">float</span></dt><dd><p>Unit-reference for phase time duration.</p>
</dd>
<dt><strong>targets</strong><span class="classifier">iterable of str</span></dt><dd><p>Targets in the ODE for the value of current time.</p>
</dd>
<dt><strong>time_phase_targets</strong><span class="classifier">iterable of str</span></dt><dd><p>Targets in the ODE for the value of current phase elapsed time.</p>
</dd>
<dt><strong>t_initial_targets</strong><span class="classifier">iterable of str</span></dt><dd><p>Targets in the ODE for the value of phase initial time.</p>
</dd>
<dt><strong>t_duration_targets</strong><span class="classifier">iterable of str</span></dt><dd><p>Targets in the ODE for the value of phase time duration.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.setup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Build this group.</p>
<p>This method should be overidden by your Group’s method. The reason for using this
method to add subsystem is to save memory and setup time when using your Group
while running under MPI.  This avoids the creation of systems that will not be
used in the current process.</p>
<p>You may call ‘add_subsystem’ to add systems to this group. You may also issue connections,
and set the linear and nonlinear solvers for this group level. You cannot safely change
anything on children systems; use the ‘configure’ method instead.</p>
<dl class="simple">
<dt>Available attributes:</dt><dd><p>name
pathname
comm
options</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.simulate">
<code class="sig-name descname">simulate</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">times_per_seg=10</em>, <em class="sig-param">method='RK45'</em>, <em class="sig-param">atol=1e-09</em>, <em class="sig-param">rtol=1e-09</em>, <em class="sig-param">record_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/dymos/phase/phase.html#Phase.simulate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dymos.phase.phase.Phase.simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate the Phase using scipy.integrate.solve_ivp.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>times_per_seg</strong><span class="classifier">int or None</span></dt><dd><p>Number of equally spaced times per segment at which output is requested.  If None,
output will be provided at all Nodes.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str</span></dt><dd><p>The scipy.integrate.solve_ivp integration method.</p>
</dd>
<dt><strong>atol</strong><span class="classifier">float</span></dt><dd><p>Absolute convergence tolerance for scipy.integrate.solve_ivp.</p>
</dd>
<dt><strong>rtol</strong><span class="classifier">float</span></dt><dd><p>Relative convergence tolerance for scipy.integrate.solve_ivp.</p>
</dd>
<dt><strong>record_file</strong><span class="classifier">str or None</span></dt><dd><p>If a string, the file to which the result of the simulation will be saved.
If None, no record of the simulation will be saved.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>problem</strong><span class="classifier"></span></dt><dd><p>An OpenMDAO Problem in which the simulation is implemented.  This Problem interface
can be interrogated to obtain timeseries outputs in the same manner as other Phases
to obtain results at the requested times.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.system_iter">
<code class="sig-name descname">system_iter</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">include_self=False</em>, <em class="sig-param">recurse=True</em>, <em class="sig-param">typ=None</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.system_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Yield a generator of local subsystems of this system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>include_self</strong><span class="classifier">bool</span></dt><dd><p>If True, include this system in the iteration.</p>
</dd>
<dt><strong>recurse</strong><span class="classifier">bool</span></dt><dd><p>If True, iterate over the whole tree under this system.</p>
</dd>
<dt><strong>typ</strong><span class="classifier">type</span></dt><dd><p>If not None, only yield Systems that match that are instances of the
given type.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="dymos.phase.phase.Phase.use_fixed_coloring">
<code class="sig-name descname">use_fixed_coloring</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">coloring=&lt;object object at 0x7f47d33f61c0&gt;</em>, <em class="sig-param">recurse=True</em><span class="sig-paren">)</span><a class="headerlink" href="#dymos.phase.phase.Phase.use_fixed_coloring" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a precomputed coloring for this System.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coloring</strong><span class="classifier">str</span></dt><dd><p>A coloring filename.  If no arg is passed, filename will be determined
automatically.</p>
</dd>
<dt><strong>recurse</strong><span class="classifier">bool</span></dt><dd><p>If True, set fixed coloring in all subsystems that declare a coloring. Ignored
if a specific coloring is passed in.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<div class="toctree-wrapper compound">
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../dymos.transcriptions.html" title="dymos.transcriptions"
             >next</a> |</li>
        <li class="right" >
          <a href="options.html" title="options.py"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">dymos 0.14.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Source Docs</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../dymos.phase.html" >dymos.phase</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, National Aeronautics and Space Administration.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.3.1.
    </div>
  </body>
</html>